1. Реализуйте HTTP-сервер на **`net/http`**, который принимает числа через POST-запрос и возвращает их сумму.
2. Перепишите сервер на [Echo](https://echo.labstack.com/guide/routing/).
3. Организуйте проект по go standart project layout.
4. Сохраняйте результаты вычислений в памяти (используйте самописную потокобезопасную мапу с `sync.Mutex`, дополнительно почитайте про `sync.Map` и когда она используется).
5. Расширьте функциональность калькулятора, добавив ручку для умножения.
6. Добавьте базовое разделение запросов от пользователей: пользователь отправляет вместе с числами токен (какую-либо строку, лучше UUID), результаты сохраняются по токену (в памяти приложения).
7. Задокументируйте API через Swagger (используйте [swaggo](https://github.com/swaggo/swag)).
8. Напишите Makefile для запуска генерации документации.

1. Проект реализован вообще не по go standart project layout +
2. Отсутствует структура проекта и разбиение на слои , вся логика в одном файле , так еще и в pkg - это нечитаемо , коллеги по работе точно не очень будут рады ревьюить такое, у нас тут не олимпиадное программирование, у нас качественное продуктовое программирование +
3. Нет никакого Gracefull Shutdown +
4. Нет единообразного логирования +
5. Нет конфигурации приложения(ни чтение из файла , ни переменных окружения) - порт захардкожен
6. Тесты написаны интеграционные , это круто , но нам надо покрыть код юнит-тестами. Причем юнит тесты, а именно тестовые файлы должны лежать в одном пакете с тестируемым функионалом. 
7. Ну и нет докерфайла , чтобы быстренько кажный мог развернуть без установки golang


Чтобы добить проект до уровня хорошего продуктового кода его надо рефачить хорошо